[[chapter_2_section_2d]]

=== Logical Side-channels [Luis Fiolhais, Yann Loisel]

This section tackles logical side-channels attacks in a computing system. They
are differentiated from Physical Side-Channels as they don’t require physical
access to the computing system. However, similarly to physical side-channels,
logical side-channels occur when instructions defined in the ISA have
side-effects that may not be defined by the ISA. These side-effects
can be exploited by a malicious user to recover information from a past or
concurrent execution of a victim. Often these side-effect occur due to the
difference between the intuitive programmer model the programmer uses and the
specification of the architectural model and the non-architectural model.

This section interprets logical side-channel attacks in two broad categories:
*Architectural Type Attacks* which require the victim to commit instructions
in order for the attacker to recover information; and *Non-Architectural Type
Attacks* which don't require the victim to commit instructions. Regardless of
the means used to transfer information between an attacker and a victim, the
goal of the attacker is to obtain the victim's information through a
non-inter-process communication explcitly defined by the execution
environment.

== Architectural Type Attacks
Architectural attack types require instructions to be commited by the victim's
hart in order for an attacker to recover information. The committed instructions
will change the non-architectural state such that the attacker can recover
information the victim was/is operating on.

= Timing Side-Channel Attacks
Timing side-channel attacks are defined by the usage of a high-resolution timer
to infer what data was transmitted in a communication channel. The timer
can be provided by the platform or it can be created by the attacker. In this
scenario, the attacker will change the non-architectural state such that the
victim will have a different execution time. Depending on the execution time
the attacker can infer what data the victim was processing. Timing
side-channels can be created in multiple ways. The simplest way is to time
the victim before and after execution, giving it different inputs. If the
victim has a non-constant time runtime with different input, the attacker can
infer the victim's data. However, the most popular way is to change the state
of the cache hierarchy in particular ways such that the attacker can infer what
memory addresses the victim used, and, from that information, infer what data
the victim is operating on. There are other available methods such as: the
latency of the memory controller, interrupt handling, and functional unit
contention in multi-harted physical cores.

= Performance Counter Side-Channel Attacks
Traditionally, harts offer high-resolution performance counters, in the
architectural state, to help programmers optimize their code. These counters
can be programmed to keep track of architectural and non-architectural events.
If these counters are available to both a victim and an attacker. An attacker
will be able to read the events created by the victim and infer what data it
was processing on. These counters range from cycle counters, to multi-level
cache misses, and mispredictions.

= Power Side-Channel Attacks
Power side-channel attacks, in the logical domain, are defined by the usage of
high-resolution power readers, available in the microarchitecture, to infer
what data was transmitted in a communication channel. This counter may be
updated on every microarchitectural, thus providing a information on what kind
of instructions a victim is executing. Some architectures share the same power
counter across all harts, privilege levels, and security domains within the
same physical core, or even within the same platform. Therefore, an OS will
not context switch this architectural register and the power information will
be available to an attacker.

Another way to exploit power side-channels is to use power architectural
registers to undervolt, overvolt, or increase the clock frequency of a phsycial
core in a platform to inject hardware faults. These hardware faults, in turn,
provide information for an attacker to infer what a victim is computing.

== Non-Architectural Type Attacks
The previous attack type requires a victim to perform modifications to
the architectural state in order to complete an attack. However, some
instructions don’t have to be committed to modify the non-architectural state.
These type of attacks are referred to in the state-of-the-art as Transient-Execution
Attacks (TEA). The observation is that, in TEAs, even though the victim doesn't
have to commit instructions, their execution provide a side-effect that can be measured
by the attacker. Instructions that have measurable side-effects when executed are called
*transient instructions*.

The standard operational model of this attack type requires the
victim to stall the commit stage due to a sequence of high-latency operations.
The timing window created by stalling commit stage is referred to as the *transient window*.
Within the transient window, the victim must access and transfer data to the attacker through
a non-inter-process communication channel.
The simplest method to create a transient window is to perform a load that misses in the TLB,
and keeps missing while walking the page table, and is followed by a cache hierarchy miss using
the physical address. The missing scenario can be created by the attacker as
the cache hierarchy is traditionally shared between all physical cores.
Since the amount of data transferred within the transient window depends on its size, the
attacker has a desire to extend it.

To maximize the size of the transient window, the victim can execute and commit loads that will
also miss the TLB and the cache hierarchy that depend on the previous load with the same
properties. In theory, this kind of transient window can be extended to an arbitrary
large latency chosen by the attacker as it depends on the state of the cache hierarchy. The number
of transient instructions executed by the victim, while the commit stage is stalled, will depend on
the size of the ROB and the latency of the pointer chasing. However, there are other methods to
create a transient window that can result in the same or higher latency. For example, if a part
of a physical core is strongly power-gated, e.g., traditionally the vector unit, disabling and
enabling the power-gating on vector unit may have a higher latency than a sequence of TLB and cache
hierarchy misses. Even though this text presents two examples of creating and extending a transient
window they are not the only two in existence. Generally, the size and creation of the transient
window depend on the targeted microarchitecture.

All of the previous described attack subtypes (timing, performance, and power) may be
deployed in non-architectural attacks. In timing side-channel attacks, an attacker can, for
example, change the state of the cache hierarchy, that the victim will inherit, to have measurable
timing differences when the victim executes. In performance counter side-channel attacks,
the contents of the counters for non-architectural events are still updated regardless of
committed instructions. In power side-channel attacks, the used power counter is updated regardless
of committed instructions. Non-Architectural attacks are very powerful tool for an attacker as
they rely on implementation details of a platform and, as a result, are very difficult to detect
in software (the architectural state). They provide a stealthy approach to transfer information
across processes in any execution environment.


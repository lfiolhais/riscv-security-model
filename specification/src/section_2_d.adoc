[[chapter_2_section_2d]]

=== Logical Side-channels [Luis Fiolhais, Yann Loisel]

This section tackles logical side-channels attacks in a computing system. They
are differentiated from Physical Side-Channels as they don’t require physical
access to the computing system. However, similarly to physical side-channels,
logical side-channels occur when instructions defined in the ISA have
side-effects that are not defined by the ISA. These side-effects
can be exploited by a malicious user to recover information from a past or
concurrent execution of a victim.

This section interprets logical side-channel attacks in two broad categories:
*Architectural Type Attacks* which require the victim to commit instructions
in order for the attacker to recover information; and *Non-Architectural Type
Attacks* which don't require the victim to commit instructions. Regardless of
the means used to transfer information between an attacker and a victim, the
goal of the attacker is to obtain the victim's information through a
non-inter-process communication explcitly defined by the execution
environment.

== Architectural Type Attacks
Architectural attack types require instructions to be commited by the victim's
hart in order for an attacker to recover information. The committed instructions
will change the non-architectural state such that the attacker can recover
information the victim was/is operating on.

= Timing Side-Channel Attacks
Timing side-channel attacks are defined by the usage of a high-resolution timer
to infer what data was transmitted in a communication channel. The timer
can be provided by the platform or it can be created by the attacker. In this
scenario, the attacker will change the non-architectural state such that the
victim will have a different execution time. Depending on the execution time
the attacker can infer what data the victim was processing. Timing
side-channels can be created in multiple ways. The simplest way is to time
the victim before and after execution, giving it different inputs. If the
victim has a non-constant time runtime with different input, the attacker can
infer the victim's data. However, the most popular way is to change the state
of the cache hierarchy in particular ways such that the attacker can infer what
memory addresses the victim used, and, from that information, infer what data
the victim is operating on. There are other available methods such as: the
latency of the memory controller, interrupt handling, and functional unit
contention in multi-harted physical cores.


= Power Side-Channel Attacks
Power side-channel attacks, in the logical domain, are defined by the usage of
high-resolution power readers, available in the microarchitecture, to infer
what data was transmitted in a communication channel. This counter may be
updated on every microarchitectural, thus providing a information on what kind
of instructions a victim is executing. Some architectures share the same power
counter across all harts, privilege levels, and security domains within the
same physical core, or even within the same platform. Therefore, an OS will
not context switch this architectural register and the power information will
be available to an attacker.

Another way to exploit power side-channels is to use power architectural
registers to undervolt, overvolt, or increase the clock frequency of a phsycial
core in a platform to inject hardware faults. These hardware faults, in turn,
provide information for an attacker to infer what a victim is computing.

= Memory Controller

== Non-Architectural Type Attacks
The previous attack type requires a victim to perform modifications to
the architectural state in order to complete an attack. However, some
instructions don’t have to be committed to modify the non-architectural state.

= Transient-Execution Attacks
Transient-Execution Attacks (TEA).

= Memory Controller

